# [SeSAC 도봉] 2일차 : 데이터의 구조와 논리의 설계

어제 비로소 개발자로서의 기록을 시작하겠다는 다짐을 하고, 오늘은 그 다짐을 증명이라도 하듯 데이터베이스 모델링이라는 거대한 과제를 수행했습니다. 지금까지는 주어진 데이터를 어떻게 가공할지 고민했다면, 오늘은 그 데이터가 태초에 어떻게 저장되고 연결되어야 하는지를 고민하는 시간이었습니다.

단순히 테이블을 그리는 작업이 아니라, 현실 세계의 복잡한 관계를 디지털 세계로 옮겨오는 설계자의 관점을 갖게 된 하루였습니다.

---

## 1. 현실을 데이터로 번역하는 과정

코드를 잘 작성하는 것도 중요하지만, 잘못 설계된 데이터 위에서는 좋은 코드가 나올 수 없다는 사실을 확인했습니다. 우리가 매일 사용하는 서비스들이 겉보기엔 단순해 보였지만, 그 이면에는 치밀하게 계산된 데이터의 연결고리가 존재했습니다.

### 음원 서비스 설계의 디테일

가수와 노래를 연결하는 과정에서 가장 큰 배움을 얻었습니다. 처음에는 가수와 노래를 단순히 선으로 이으면 된다고 생각했습니다. 하지만 한 노래를 여러 가수가 부르는 경우나 그룹과 솔로 가수의 관계 등을 고려했을 때 기존 설계의 한계가 드러났습니다.

이를 해결하기 위해 가수와 노래 사이에 연관 테이블을 두었고, 여기에 단순 매핑뿐만 아니라 역할이나 참여 형태 같은 구체적인 정보를 담아야 비로소 서비스가 작동한다는 것을 배웠습니다. 또한 그룹과 멤버를 별도 테이블로 쪼개기보다 아티스트라는 상위 개념으로 통합하고, 자기 참조 등을 활용하는 설계에서 유연함을 엿볼 수 있었습니다.

### SNS와 도서관 시스템의 구조화

인스타그램과 도서관 시스템을 설계하며 데이터의 무결성과 현실 반영 사이에서 깊은 고민을 했습니다. 게시글 하나에 사진이 여러 장 들어가는 구조에서 무리하게 컬럼을 늘리는 대신, 미디어 테이블을 별도로 분리하여 관리해야 한다는 점을 배웠습니다.

특히 도서관 예제에서는 추상적인 정보인 책과 실제로 도서관에 꽂혀 있는 실물 아이템을 구분해야 한다는 점이 인상적이었습니다. 정보와 실체를 분리하여 설계하는 이 사고방식이야말로 개발자가 갖춰야 할 추상화 능력임을 확신할 수 있었습니다.

## 2. 오늘의 집중 학습 : 객체지향의 논리 구조

학원에서 데이터의 저장 구조를 배웠다면, 개인 학습 시간에는 정보를 처리하는 논리의 구조인 객체지향 프로그래밍을 복습하는 데 집중했습니다.

### 설계도와 실체의 구분

클래스는 설계도에 비유할 수 있고 객체는 그 틀에서 나온 실제 제품에 해당합니다. 중요한 점은 설계도 안에 정의된 함수들이 서로 남남이 아니라 셀프라는 연결고리를 통해 하나의 자아를 공유한다는 사실입니다. 상태를 변화시키는 행동과 그 상태를 사용하는 행동이 유기적으로 연결되어 있음을 이해했습니다.

### 객체 간의 협력과 책임

은행 계좌와 도서관 시스템 코드를 다시 작성해보며 객체 간의 협력을 실습했습니다. 계좌 이체 기능을 구현할 때 내 통장에서 돈을 빼는 행위와 상대방 통장에 돈을 넣는 행위는 서로 다른 객체에서 일어납니다. 이때 내가 상대방의 잔액을 직접 수정하는 것이 아니라, 상대방 객체에게 입금해달라는 메시지를 보내는 방식으로 구현해야 한다는 점을 명확히 했습니다.

```python
class Library:
    def __init__(self):
        self.books = []  # 도서관은 빈 리스트로 시작

    def add_book(self, book):
        self.books.append(book)

    def borrow_book(self, title):
        for book in self.books:
            # 책을 찾고 대출 가능 상태인지 확인
            if book.title == title and book.status == "available":
                book.borrow()  # 책 객체에게 상태 변경을 요청
                print(f"{title} 대출 완료")
                return
        print("책이 없거나 대출 중입니다.")
단순히 코드를 짜는 것을 넘어, 객체에게 적절한 책임을 부여하고 서로 협력하게 만드는 것이 객체지향 설계의 핵심임을 깨달았습니다.

데이터베이스 설계 과정에서 익힌 데이터의 구조화 능력과 객체지향 프로그래밍에서 익힌 논리의 구조화 능력은 서로 다른 듯하지만, 결국 견고한 소프트웨어를 만든다는 하나의 목표를 향해 있습니다. 오늘 정립한 이 구조적인 사고방식은 앞으로 마주할 더 복잡한 문제들을 해결하는 데 강력한 무기가 되리라 믿습니다.
```
