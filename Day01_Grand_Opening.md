# [SeSAC 도봉] 1개월 차 회고와 기록의 시작 : 구조적인 개발자로의 도약

새싹 도봉 과정에 합류하여 프로그래밍의 세계에 발을 들인 지 어느덧 한 달이라는 시간이 흘렀습니다. 그동안은 새로운 개념을 머릿속에 집어넣고 코드를 따라가는 데 급급하여, 정작 내 것으로 만드는 정리의 시간을 갖지 못했던 것이 사실입니다.

늦었다고 생각할 때가 가장 빠를 때라는 말처럼, 오늘부터는 단순히 기능을 구현하는 코더가 아닌 데이터를 효율적으로 설계하고 다루는 개발자로 성장하기 위해 지나온 과정과 앞으로의 배움을 기록으로 남기고자 합니다.

---

## 1. 지난 1개월 과정 회고

지난 한 달은 프로그래밍 언어의 문법을 익히는 시기를 지나, 데이터가 어떻게 흐르고 저장되는지 전체적인 구조를 파악하는 시간이었습니다.

### 파이썬 기초 논리와 사고의 확장

개발의 가장 기본이 되는 언어적 규칙을 익히는 과정은 생각보다 순탄치 않았습니다. 정수나 문자열 같은 자료형은 직관적으로 이해할 수 있었으나, 조건문이나 반복문 등을 통해 컴퓨터에게 논리적인 명령을 내리는 과정에서 어려움을 겪었습니다. 머릿속으로 구상한 로직이 코드로 옮겨지지 않는 답답함이 있었고, 특히 복잡한 조건문과 반복문이 섞일 때면 사고가 정지되는 경험을 하기도 했습니다.

이러한 막막함을 해결하기 위해 생성형 AI를 적극적으로 활용했습니다. 단순히 답을 묻는 것이 아니라 취약한 부분에 대한 예제 문제를 만들어달라고 요청하고, 이를 풀며 해설을 듣는 방식으로 복습을 진행했습니다. 끊임없이 왜라는 질문을 던지고 문제를 해결해 나가는 과정을 통해 비로소 컴퓨터의 사고방식에 익숙해질 수 있었습니다.

### 객체지향 프로그래밍과 설계

절차지향적인 코드의 한계를 넘어, 유지보수가 용이하고 확장 가능한 소프트웨어를 만들기 위해 클래스를 학습했습니다. 이론 수업과 자판기, 스마트홈, RPG 게임 등의 미니 프로젝트를 거치며 객체 간의 상호작용과 상속의 개념을 접했습니다.

솔직히 말해 아직은 절반 정도만 이해한 느낌입니다. 기능을 구현하는 것은 가능하지만 이것이 최선의 설계인가라는 질문에는 아직 자신 있게 답하기 어렵습니다. 하지만 코드를 기능별로 묶어 객체화했을 때의 구조적 장점은 확실히 느꼈기에, 지속적인 복습과 실습을 통해 부족함을 채워나갈 생각입니다. 지금의 부족함은 곧 성장의 가능성이라 믿습니다.

### 데이터의 통신과 저장

내 컴퓨터 안에서만 작동하는 프로그램을 넘어, 외부 세계와 데이터를 주고받는 기술을 익혔습니다. REST API와 비동기 통신 부분은 의외로 수월하게 다가왔습니다. 과거 경험했던 부트캠프에서 소위 따라 하기 식으로 프로젝트를 진행하며 웹사이트를 만들어본 경험이 도움이 되었습니다.

그때는 원리를 모르고 복사해서 쓰기에 바빴다면, 지금은 JSON 데이터가 어떻게 파싱되고 흐르는지 구조가 눈에 보인다는 점이 다릅니다. TMDB, Upbit 등 실제 API를 다루며 데이터 통신에 대한 자신감을 얻을 수 있었습니다.

---

## 2. 오늘의 집중 학습 : 기초 점검과 자료구조의 효율성

오늘 하루는 그동안 쌓아온 기초 지식을 검증하고, 이를 바탕으로 자료구조의 효율성을 깊이 파고드는 데 집중했습니다.

### 중간 점검과 확신

Gemini를 통해 생성한 파이썬 기초 문법 10문제를 풀어보며 자체 중간 평가를 진행했습니다. 제어문부터 자료구조까지 핵심 개념을 아우르는 문제들이었고, 결과는 만점이었습니다. 학습 초반, 반복문 하나를 작성하는 데도 어려움을 겪던 모습을 생각하면 괄목할 만한 성장이었습니다. 막연하게 알고 있다고 생각했던 개념들이 실제로도 탄탄하게 잡혀있음을 확인하니, 앞으로의 심화 학습에 대한 확신을 가질 수 있었습니다.

### 알고리즘 : 리스트와 덱의 차이

기초 체력을 확인한 후, 곧바로 자료구조의 실무적 적용으로 넘어갔습니다. 특히 데이터를 선입선출로 처리하는 큐 구조에서 자료형 선택의 중요성을 절감했습니다.

파이썬의 리스트는 첫 번째 요소를 제거하면 맨 앞 데이터를 빼낸 뒤, 뒤에 있는 모든 데이터를 한 칸씩 앞으로 당겨야 합니다. 이는 O(N)의 시간이 소요되어 데이터가 많아질수록 비효율적입니다. 반면 collections.deque의 popleft 메서드는 데이터 이동 없이 즉시 처리가 가능하여 O(1)의 시간 복잡도를 가집니다.

```python
from collections import deque

def solve_card(n):
    # 1부터 N까지의 카드를 Deque에 적재 (O(N))
    queue = deque(range(1, n + 1))

    while len(queue) > 1:          # 카드가 한 장 남을 때까지 반복
        queue.popleft()            # 1. 맨 위 카드를 버림 (O(1))
        queue.append(queue.popleft()) # 2. 그 다음 카드를 맨 뒤로 옮김 (O(1))

    return queue[0]                # 최후에 남은 카드 반환

단순히 문제를 푸는 것을 넘어, 왜 이 도구를 써야 하는가를 이해하는 것이 알고리즘 공부의 핵심임을 깨달았습니다.

3. 앞으로의 목표
지난 한 달이 개발에 필요한 도구들의 사용법을 익히는 시간이었다면, 앞으로는 이 도구들을 적재적소에 활용하여 견고한 소프트웨어를 설계하는 능력을 키우고자 합니다. 매일 배운 내용을 흘려보내지 않고 꾸준히 기록하여, 나만의 단단한 지식 베이스를 구축해 나갈 것입니다.
```
