# [SeSAC 도봉] 1달만에 시작하는 기록 : 구조적인 개발자로의 도약

새싹 도봉 과정에 합류하여 프로그래밍의 세계에 발을 들인 지 어느덧 한 달이라는 시간이 흘렀다.
그동안은 새로운 개념을 머릿속에 집어넣고 코드를 따라가는 데 급급하여, 정작 내 것으로 만드는 '정리'의 시간을 갖지 못했던 것이 사실이다.
늦었다고 생각할 때가 가장 빠를 때라는 말처럼, 오늘부터는 단순히 기능을 구현하는 코더(Coder)가 아닌, 데이터를 효율적으로 설계하고 다루는 개발자(Developer)로 성장하기 위해 지나온 과정과 앞으로의 배움을 기록으로 남기려 한다.

---

## 1. 지난 1달간의 여정

지난 한 달은 프로그래밍이라는 언어의 문법을 익히는 시기를 지나, 데이터가 어떻게 흐르고 저장되는지 전체적인 구조를 파악하는 시간이었다.

### 🔹 파이썬 기초 논리와 사고의 확장

개발의 가장 기본이 되는 언어적 규칙을 익히는 과정은 생각보다 순탄치 않았다.
`int`, `str` 같은 자료형은 직관적으로 이해가 갔으나, `if`, `for`, `while` 등의 제어문을 통해 컴퓨터에게 논리적인 명령을 내리는 과정에서 꽤나 애를 먹었다.
머릿속으로는 그려지는 로직이 코드로 옮겨지지 않는 답답함이 있었고, 특히 복잡한 조건문과 반복문이 섞일 때면 사고가 꼬이는 경험을 자주 했다.

이러한 막막함을 해결하기 위해 생성형 AI(Gemini)를 적극적으로 활용했다. 단순히 답을 묻는 것이 아니라, 내가 약한 부분에 대한 예제 문제를 만들어달라고 요청하고, 이를 풀며 해설을 듣는 방식으로 복습을 진행했다.
끊임없이 "왜?"라는 질문을 던지고 문제를 해결해 나가는 과정을 통해, 비로소 컴퓨터의 사고방식에 익숙해질 수 있었다.

### 🔹 객체지향 프로그래밍과 설계 (OOP)

절차지향적인 코드의 한계를 넘어, 유지보수가 용이하고 확장 가능한 소프트웨어를 만들기 위해 클래스(Class)를 학습했다.
이론 수업과 미니 프로젝트(`Vending Machine`, `SmartHub`, `RPG Game`)를 거치며 객체 간의 상호작용과 상속의 개념을 접했지만, 솔직히 말해 아직은 '반절' 정도만 이해한 느낌이다.
기능을 구현하는 것은 가능하지만, "이게 최선의 설계인가?"라는 질문에는 아직 자신 있게 답하기 어렵다.
하지만 코드를 기능별로 묶어 객체화했을 때의 구조적 아름다움은 확실히 느꼈기에, 지속적인 복습과 실습을 통해 이 부족함을 채워나갈 생각이다. 지금의 부족함은 곧 성장의 가능성이라 믿는다.

### 🔹 데이터의 통신과 저장 (REST API & Web)

내 컴퓨터 안에서만 돌아가는 프로그램을 넘어, 외부 세계와 데이터를 주고받는 기술을 익혔다.
REST API와 비동기(`Async`) 통신 부분은 의외로 수월하게 다가왔다. 과거 '찍먹'으로 경험했던 부트캠프에서 소위 '바이브 코딩'으로 프로젝트를 진행하며 웹사이트를 만들어본 경험이 도움이 되었다.
그때는 원리를 모르고 복사해서 쓰기에 바빴다면, 지금은 `JSON` 데이터가 어떻게 파싱되고 흐르는지 구조가 눈에 보인다는 점이 다르다. `TMDB`, `Upbit` 등 실제 API를 다루며 데이터 통신에 대한 자신감을 얻을 수 있었다.

---

## 2. 오늘의 집중 학습 : 기초 점검과 자료구조의 효율성

오늘 하루는 그동안 쌓아온 기초 지식을 검증하고, 이를 바탕으로 자료구조의 효율성을 깊이 파고드는 데 집중했다.

### 💡 중간 점검 : 10문제의 확신

Gemini를 통해 생성한 **'파이썬 기초 문법 10문제'**를 풀어보며 자체 중간 평가를 진행했다.
제어문(Control Flow)부터 자료구조(List, Dict)까지 핵심 개념을 아우르는 문제들이었고, 결과는 **10점 만점**이었다.
학습 초반, 반복문 하나를 짜는 데도 쩔쩔매던 모습을 생각하면 괄목할 만한 성장이었다. 막연하게 "알고 있다"고 생각했던 개념들이 실제로도 탄탄하게 잡혀있음을 확인하니, 앞으로의 심화 학습에 대한 확신을 가질 수 있었다.

### 💡 알고리즘 : List vs Deque의 차이

기초 체력을 확인한 후, 곧바로 자료구조의 실무적 적용(알고리즘)으로 넘어갔다. 특히 데이터를 선입선출(FIFO)로 처리하는 `Queue` 구조에서 자료형 선택의 중요성을 절감했다.

- **List의 한계:** 파이썬의 리스트는 `pop(0)`을 수행하면 맨 앞 데이터를 빼낸 뒤, 뒤에 있는 모든 데이터를 한 칸씩 앞으로 당겨야 한다. 이는 $O(N)$의 시간이 소요되어 비효율적이다.
- **Deque의 발견:** 반면 `collections.deque`의 `popleft()`는 데이터 이동 없이 즉시 처리가 가능하다($O(1)$).

**[실습: 백준 2164 - 카드2]**

```python
from collections import deque

def solve_card(n):
    # 1부터 N까지의 카드를 Deque에 적재 (O(N))
    queue = deque(range(1, n + 1))

    while len(queue) > 1:          # 카드가 한 장 남을 때까지 반복
        queue.popleft()            # 1. 맨 위 카드를 버림 (O(1))
        queue.append(queue.popleft()) # 2. 그 다음 카드를 맨 뒤로 옮김 (O(1))

    return queue[0]                # 최후에 남은 카드 반환

단순히 문제를 푸는 것을 넘어, **'왜 이 도구를 써야 하는가'**를 이해하는 것이 알고리즘 공부의 핵심임을 깨달았다.

3. 앞으로의 목표
지난 한 달이 개발에 필요한 도구들의 사용법을 익히는 시간이었다면, 앞으로는 이 도구들을 적재적소에 활용하여 견고한 소프트웨어를 설계하는 능력을 키우고자 한다. 매일 배운 내용을 흘려보내지 않고 꾸준히 기록하여, 나만의 단단한 지식 베이스를 구축해 나갈 것이다.
```
