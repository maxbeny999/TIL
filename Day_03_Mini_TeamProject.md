# [SeSAC 도봉] 3일차 : 설계의 본질과 객체의 확장

협업을 통해 머릿속의 논리를 가시적인 설계도로 옮기는 과정을 경험했습니다. 오전에는 동료와 함께 데이터베이스의 스키마를 설계하며 현실 세계의 불명확한 관계를 명확한 데이터 구조로 정의하는 훈련을 했고, 오후에는 파이썬의 객체지향 문법과 알고리즘을 다루며 코드의 재사용성과 논리적 완결성을 점검했습니다. 개발이란 단순히 기능을 구현하는 것이 아니라, 견고한 구조를 쌓아 올리는 과정임을 다시금 확인한 하루였습니다.

---

## 1. 팀 프로젝트 : 온라인 강의 사이트 스키마 설계

2인 1조로 진행된 미니 프로젝트의 목표는 '온라인 강의 사이트'의 데이터베이스 모델링이었습니다. 사용자에게 보이는 직관적인 서비스 흐름 이면에, 데이터 무결성을 보장하기 위한 치밀한 설계가 필요함을 절감했습니다.

![image](C:\sesac_prac\sql\erd\study_mini_project\erd.png)

### 다대다(N:M) 관계의 해소와 실체화

가장 많은 논의가 오갔던 부분은 학생과 강의 사이의 관계였습니다. 한 명의 학생은 여러 강의를 수강할 수 있고, 하나의 강의는 여러 학생에게 제공됩니다. 이러한 다대다 관계를 물리적 테이블로 직접 연결할 경우 데이터의 중복이 발생하고 관리가 불가능해짐을 확인했습니다.

우리는 이를 해결하기 위해 수강 신청(Enrollment)이라는 중간 엔티티를 도출했습니다. 이 테이블은 단순히 학생과 강의를 연결하는 링크 역할을 넘어, 수강 신청 시점, 수료 여부, 현재 진도율과 같은 관계 고유의 속성을 담아내는 그릇이 되었습니다. 결국 데이터베이스 설계란 현실의 복잡한 상호작용을 가장 작은 단위의 논리적 실체로 분해하고, 이를 관계라는 접착제로 다시 조립하는 과정임을 깨달았습니다.

### 계층 구조의 설계와 무결성

콘텐츠 관리 측면에서는 강의(Course) 하위에 섹션(Section)이 존재하고, 섹션 하위에 실제 영상(Video)이 존재하는 계층형 구조를 설계했습니다. 상위 개념이 삭제될 때 하위 데이터가 고립(Orphan)되지 않도록 외래 키 제약 조건과 CASCADE 전략을 고민했습니다. 이는 데이터가 단순히 저장되는 공간이 아니라, 서로 유기적으로 연결된 생명체처럼 관리되어야 함을 의미합니다.

---

## 2. 개인 학습 : 언어의 본질과 논리적 사고

오후에는 파이썬의 심화 문법과 알고리즘 문제 풀이에 집중했습니다.

### 클래스(Class) : 상속과 다형성의 구조적 가치

기초 문법 8문제와 클래스 심화 4문제를 풀며, 객체지향 프로그래밍(OOP)의 핵심인 상속(Inheritance)을 깊이 있게 파고들었습니다. 단순히 코드를 줄이기 위해 부모 클래스를 상속받는 것이 아니라, 부모 클래스가 정의한 추상적인 역할을 자식 클래스가 구체화하는 과정으로 이해했습니다.

특히 `super()` 함수를 통해 부모의 초기화 로직을 그대로 유지하면서 자식 클래스만의 속성을 추가하는 패턴은, 소프트웨어의 유지보수성을 결정짓는 중요한 설계 원칙(OCP)과 맞닿아 있음을 확인했습니다. 기능의 확장은 열려 있어야 하고, 기존 코드의 수정은 닫혀 있어야 한다는 원칙을 코드로 체감하는 시간이었습니다.

### 알고리즘 : 도구보다 앞서는 논리

두 개의 알고리즘 문제를 해결하며 문법보다 논리가 선행되어야 함을 다시금 느꼈습니다. 코드를 바로 작성하기보다 문제의 요구사항을 분석하고, 입력 데이터의 크기에 따라 어떤 자료구조를 선택해야 효율적인지를 먼저 설계했습니다. 풀리지 않는 문제는 대부분 문법을 몰라서가 아니라, 문제를 해결하는 절차적 사고가 부족했기 때문이었습니다.

```python
# 클래스 상속을 통한 기능 확장의 예시
# 부모 클래스는 공통된 속성과 행위를 정의합니다.
class LearningMaterial:
    def __init__(self, title, duration):
        self.title = title
        self.duration = duration

    def info(self):
        return f"자료명: {self.title}, 길이: {self.duration}분"

# 자식 클래스는 부모의 기능을 물려받되, 자신만의 고유한 속성을 확장합니다.
class VideoLecture(LearningMaterial):
    def __init__(self, title, duration, video_url):
        # super()를 사용하여 부모의 검증된 초기화 로직을 재사용합니다.
        super().__init__(title, duration)
        self.video_url = video_url

    # 부모의 메서드를 오버라이딩하여 더 구체적인 정보를 제공합니다.
    def info(self):
        base_info = super().info()
        return f"{base_info}, URL: {self.video_url}"
```
